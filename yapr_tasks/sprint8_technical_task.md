# Добавляем продолжительность и дату старта

Добавьте новые поля и методы в задачи:
- `duration` — продолжительность задачи, оценка того, сколько времени она займёт в минутах. 
Это значение требуется хранить в экземпляре класса `Duration`.
- `startTime` — дата и время, когда предполагается приступить к выполнению задачи. 
Здесь лучше всего подойдёт `LocalDateTime`.
- `getEndTime()` — дата и время завершения задачи, которые рассчитываются исходя из `startTime` и `duration`.

Менять сигнатуры методов интерфейса `TaskManager` не понадобится: 
при создании или обновлении задач все его методы будут принимать и возвращать объект, в который вы добавите два новых поля.
А вот с классом `Epic` нужно поработать дополнительно. 
Продолжительность эпика — сумма продолжительностей всех его подзадач. 
Время начала — дата старта самой ранней подзадачи, а время завершения — время окончания самой поздней из задач. 
Новые поля `duration` и `startTime` этого класса будут расчётные — аналогично полю «статус». 
Для реализации `getEndTime()` удобно добавить поле `endTime` в `Epic` и рассчитать его вместе с другими полями.

Также не забудьте:
доработать опцию сохранения состояния в файл — добавьте в методы сериализации/десериализации новые поля;
добавить в тесты проверку новых полей (иначе IntelliJ IDEA не скомпилирует проект из-за возможных изменений в методах).

# Выводим список задач в порядке приоритета

Отсортируйте все задачи по приоритету — то есть по `startTime`. 
Напишите новый метод `getPrioritizedTasks`, возвращающий список задач и подзадач в заданном порядке.
Предполагается, что пользователь будет часто запрашивать этот список, поэтому подберите подходящую структуру данных для хранения. 
Сложность получения должна быть уменьшена с O(n∗log(n)) до O(n).
Дата начала задачи по каким-то причинам может быть не задана. 
Тогда при добавлении её не следует учитывать в списке задач и подзадач, отсортированных по времени начала. 
Такая задача не влияет на приоритет других, а при попадании в список может сломать логику работы компаратора.

# Проверяем пересечения с помощью Stream API

Предполагается, что пользователь будет выполнять не более одной задачи за раз. 
Научите трекер проверять, что задачи и подзадачи не пересекаются по времени выполнения:
Добавьте валидацию во время создания или изменения задач и подзадач.
Реализуйте метод, который будет проверять, пересекаются ли две задачи по времени выполнения, и возвращать `true` или `false`. 
Для его реализации используйте математический метод наложения отрезков.
В методе `add` выполните проверку, пересекается ли добавляемая задача с любой другой в списке менеджера. 
Для этого используйте Stream API и метод, который вы реализовали в предыдущем пункте.

# Меняем циклы на Stream API

В некоторых местах кода вы использовали разные циклы `foreach` — например, в методе `TaskManager.getEpicSubtasks(int epicId)`. 
С помощью Stream API преобразуйте операции в этих методах и избавьтесь от временных переменных.

# Покрываем код тестами

Ваша цель — написать отдельный тест для оставшихся публичных методов: стандартный кейс работы и граничные случаи. 
Потребуются следующие тесты.
Для расчёта статуса `Epic`. 

Граничные условия:

a. Все подзадачи со статусом `NEW`.
b. Все подзадачи со статусом `DONE`.
c. Подзадачи со статусами `NEW` и `DONE`.
d. Подзадачи со статусом `IN_PROGRESS`.

Для двух менеджеров задач `InMemoryTaskManager` и `FileBackedTaskManager`.

a. Чтобы избежать дублирования кода, нужен базовый класс с тестами на каждый метод из интерфейса `abstract class TaskManagerTest<T extends TaskManager>`.
b. Для подзадач нужно дополнительно проверить наличие эпика, а для эпика — расчёт статуса.
c. Добавить тест на корректность расчёта пересечения интервалов.

Для `HistoryManager` — тесты для всех методов интерфейса. Граничные условия:

a. Пустая история задач.
b. Дублирование.
c. Удаление из истории: начало, середина, конец.

Корректный перехват исключений при работе с файлами: для этого используйте утилитарные методы JUnit — `Assertions.assertThrows(…)` 
и `Assertions.assertDoesNotThrow(…)`. Эти методы получают на вход класс-исключение и экземпляр анонимного класса/лямбду. 
В единственном методе реализуется вызов того кода, который потенциально может вызвать исключение. Например:

``` @Test
     public void testException() {
         assertThrows(ArithmeticException.class, () -> {
             int a = 10 / 0;
         }, "Деление на ноль должно приводить к исключению");
     }
 ```

После написания тестов ещё раз проверьте их наличие по списку. Убедитесь, что они работают.

# Дополнительные задания

А теперь необязательные задания для тех, кто хочет бросить себе вызов! 
Если у вас останется время, вы можете выполнить одно из них или сразу оба.

- Используйте тип `Optional`, чтобы возвращать результат методов поиска задачи/подзадачи по `id`.
- Подумайте, какая структура данных и какой алгоритм проверки подойдут, чтобы уменьшить сложность поиска пересечений до O(1).

